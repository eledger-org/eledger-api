<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"dbUpgrade.js.html":{"id":"dbUpgrade.js.html","title":"Source: dbUpgrade.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: dbUpgrade.js &quot;use strict&quot;; var _ = require(&quot;underscore&quot;); var Log = require(&quot;node-android-logging&quot;); var mysqlc = require(&quot;./mysqlc&quot;); var Q = require(&quot;q&quot;); var squel = require(&quot;squel&quot;); /** * addCreate builds the list of create statements necessary to create the database from scratch * * This is unordered because I'm not using foreign keys, so the order of creation doesn't matter. * * Foreign key constraints must be handled by the software instead. * * @param {String} query The query string for initially creating the model for a brand new database */ function addCreate(query) { if (this.create === undefined) { this.create = Array(); } this.create.push({ query: query }); } /** * addMigrate builds the list of migration statements necessary to upgrade a database from any version to * the latest * * @param {Number} sortFloatIndex * The sortFloatIndex in the ordered list to execute this migration statement. * Filling in this value requires the developer to manually search through all * of the models ({APP_ROOT}/models/*) in order to locate the highest * sortFloatIndex used so far. The new call to this function should be one * higher. This can be a decimal, so that you can insert between items if need * be, but not more granular than 0.001 (I am multiplying by 1000 and storing * in a BIGINT UNSIGNED field. * @param {String} query The query string for initially creating the model for a brand new database */ function addMigrate(sortFloatIndex, query) { if (this.migrate === undefined) { this.migrate = Array(); } // If there's an existing migrate statement with the same sortFloatIndex let migratesFiltered = _.filter(this.migrate, function(migrateItem) { return migrateItem.sortFloatIndex === sortFloatIndex; }); if (migratesFiltered.length &gt; 0) { Log.E(&quot;Existing migrate statement: &quot;); Log.E(migratesFiltered); Log.E(&quot;New query with the same index: &quot;); Log.E(query); throw new Error(&quot;Each call to this function must use a unique sortFloatIndex parameter&quot;); } else { this.migrate.push({ sortFloatIndex: sortFloatIndex, query: query }); } } function upgrade() { let model = this; let query = &quot;SHOW TABLES&quot;; /* List all of the available tables. We're looking for 0 or not 0 total to determine whether * we create the database from scratch or migrate the database using our migrate statements. * * The end of this promise block will be to resolve with an array of queries to execute. */ mysqlc.rawQueryPromise(query).then(function(result) { Log.I(result); if (result.length &gt; 0) { let query = squel.select() .from(&quot;DatabaseVersion&quot;) .toString(); Log.I(query); return mysqlc.rawQueryPromise(query).then(function(result) { return new Q.Promise(function(resolve) { Log.I(result); let dbVersion = parseInt(result[0].databaseVersion) / 1000; let queries = _.filter(model.migrate, function(migrateItem) { return dbVersion &lt; migrateItem.sortFloatIndex; }); resolve(queries.sort(function(lhs, rhs) { if (lhs.sortFloatIndex &lt; rhs.sortFloatIndex) { return -1; } else if (lhs.sortFloatIndex &gt; rhs.sortFloatIndex) { return 1; } else { throw new Error(&quot;Invalid sortFloatIndices, somehow two match.&quot;); } })); }); }); } else { return new Q.Promise(function(resolve) { resolve(model.create); }); } /* Now that we have the list of queries that we want to execute, we'll run them all in separate * promises. (Q.all does this for us) */ }).then(function(queries) { Log.I(&quot;Detected &quot; + queries.length + &quot; queries to run to bring the database to current.&quot;); return Q.all(_.map(queries, function(queryItem) { Log.I(queryItem); return mysqlc.rawQueryPromise(queryItem.query); })); /* Let's print out the highest migrate sortFloatIndex so that the next developer can easily * select a new index to use for the new model or database migration step. */ }).then(function() { return Q.Promise(function(resolve) { let maxSortFloatIndex = _.max(model.migrate, function(migrateItem) { return migrateItem.sortFloatIndex; }).sortFloatIndex; Log.I(&quot;Highest migrate sortFloatIndex: &quot; + maxSortFloatIndex); resolve(maxSortFloatIndex); }); /* Lastly, let's update the database version now that we've successfully committed our changes * to the database. */ }).then(function(maxSortFloatIndex) { let query = squel.update() .table(&quot;DatabaseVersion&quot;) .set(&quot;databaseVersion&quot;, maxSortFloatIndex * 1000) .toString(); return mysqlc.rawQueryPromise(query); /* Any errors will end up as rejections that we can print out and handle how we wish. * * The setTimeout is necessary to prevent Q from absorbing the error that we want to throw to * bring down the program upon a failure on the upgrade stack. */ }).catch(function(rejection) { Log.E(rejection); setTimeout(function() { throw new Error(&quot;Could not upgrade&quot;); }, 0); }); } function validateModel(model) { let reason; if (model.finalCreates.length === 0) { reason = model.tName + &quot;.finalCreates length is 0&quot;; } else if (model.migrates.length === 0) { reason = model.tName + &quot;.migrates length is 0&quot;; } else { module.exports.models.push(model); return; } Log.E(model); throw new TypeError(&quot;Invalid model (&quot; + reason + &quot;)&quot;); } function initializeModels() { var models = Array(); models.push(&quot;./models/DatabaseVersion&quot;); models.push(&quot;./models/LedgerEntries&quot;); models.push(&quot;./models/UploadReadings&quot;); models.push(&quot;./models/Uploads&quot;); models.push(&quot;./models/Users&quot;); models.forEach(function(modelFilePath) { let model = require(modelFilePath); module.exports.models.push(model); }); } function setupQueries() { module.exports.models.forEach(function(model) { validateModel(model); model.setupQueries(); }); } module.exports.addCreate = addCreate; module.exports.addMigrate = addMigrate; module.exports.upgrade = upgrade; module.exports.initializeModels = initializeModels; module.exports.setupQueries = setupQueries; module.exports.models = Array(); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"models_DefaultModelActions.js.html":{"id":"models_DefaultModelActions.js.html","title":"Source: models/DefaultModelActions.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: models/DefaultModelActions.js /* eslint-disable no-unused-vars */ &quot;use strict&quot;; var _ = require(&quot;underscore&quot;); var Log = require(&quot;node-android-logging&quot;); var mysqlc = require(&quot;../mysqlc&quot;); var squel = require(&quot;squel&quot;); var upgrade = require(&quot;../dbUpgrade&quot;); var tName = &quot;&quot;; var DEFAULT_OFFSET = 0; var DEFAULT_LIMIT = 10; module.exports = { tName: tName, setupQueries: setupQueries, finalCreates: [], migrates: [], DEFAULT_OFFSET: DEFAULT_OFFSET, DEFAULT_LIMIT: DEFAULT_LIMIT, select: select, count: count }; /** * Selects from the database and returns a Q.Promise to return the results. * * @param {number} [offset=0] The offset to request from within the result set * @param {number} [limit=0] The maximum number of records to request from within the result set * * @returns Q.Promise A promise to return the results * * @example * // res.json sends a JSON string containing the uploads according to the parameters passed * select().then(function(uploads) { * res.json(uploads); * }); */ function select(offset, limit) { let query = squel.select() .from(this.tName) .offset(_().coalesce(offset, this.DEFAULT_OFFSET)) .limit(_().coalesce(limit, this.DEFAULT_LIMIT)) /* .offset(_(offset, 0).coalesce(offset, 0)) .limit(_(limit, 10).coalesce(limit, 10)) */ .toString(); return mysqlc.rawQueryPromise(query); } /** * Selects the count from the given table and returns a Q.Promise to return the count. * * @returns Q.Promise A promise to return the count * * @example * // res.json sends a JSON string containing the uploads according to the parameters passed * count().then(function(uploads) { * res.json({ * count: uploads[0].count * }); * }); */ function count() { let query = squel.select() .field(&quot;COUNT(*)&quot;, &quot;count&quot;) .from(this.tName) .toString(); return mysqlc.rawQueryPromise(query); } /** * Sets up the create statements and migrate statements for each model. * * In order for this function to work, each model much specify an array of finalCreates (queries that can * build the model from scratch in the database) and migrates (queries that can upgrade the model from any * previous version). * * For an application example, see ./models/LedgerEntries.js * * @example * // Provide queries to initially create the database. * module.exports.initialCreates = [ ` * CREATE TABLE Car ( * id BIGINT UNSIGNED AUTO_INCREMENT, * color VARCHAR(255) * ); * ` ]; * * // Map the initialCreates to a migrates query. Add each subsequent modification (ALTER TABLE) to future * // sortFloatIndex values, while making sure not to step on the toes of other sortFloatIndices. * module.exports.migrates = [ * { * sortFloatIndex: 0, * query: module.exports.initialCreates[0] * } * ]; * * // Clone initialCreates initially. After alter tables, this array should always contain the latest * // queries to build the database from scratch. * module.exports.finalCreates = module.exports.initialCreates.slice(); */ function setupQueries() { this.finalCreates.forEach(function(create) { upgrade.addCreate(create); }); this.migrates.forEach(function(migrate) { upgrade.addMigrate(migrate.sortFloatIndex, migrate.query); }); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"api_controllers_UploadReadings.js.html":{"id":"api_controllers_UploadReadings.js.html","title":"Source: api/controllers/UploadReadings.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: api/controllers/UploadReadings.js &quot;use strict&quot;; var UploadReadings = require(&quot;../../models/UploadReadings&quot;); var Log = require(&quot;node-android-logging&quot;); var Q = require(&quot;q&quot;); module.exports = { get: get }; /** * get retrieves the UploadReadings from the database and returns them via the response. */ function get(request, response) { UploadReadings.select(request.query.offset, request.query.limit).then(function(uploadReadings) { return UploadReadings.count().then(function(count) { return new Q.Promise(function(resolve) { response.json({ &quot;length&quot;: uploadReadings.length, &quot;results&quot;: uploadReadings, &quot;count&quot;: count[0].count }); resolve(); }); }); }).catch(function(rejection) { Log.E(rejection); response.status(500).json({ &quot;result&quot;: &quot;ERROR&quot;, &quot;message&quot;: &quot;Unable to retrieve uploadReadings&quot; }); }); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"api_controllers_Users.js.html":{"id":"api_controllers_Users.js.html","title":"Source: api/controllers/Users.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: api/controllers/Users.js &quot;use strict&quot;; var Users = require(&quot;../../models/Users&quot;); var Log = require(&quot;node-android-logging&quot;); var Q = require(&quot;q&quot;); module.exports = { get: get }; /** * get retrieves the Users from the database and returns them via the response. */ function get(request, response) { Users.select(request.query.offset, request.query.limit).then(function(users) { return Users.count().then(function(count) { return new Q.Promise(function(resolve) { response.json({ &quot;length&quot;: users.length, &quot;results&quot;: users, &quot;count&quot;: count[0].count }); resolve(); }); }); }).catch(function(rejection) { Log.E(rejection); response.status(500).json({ &quot;result&quot;: &quot;ERROR&quot;, &quot;message&quot;: &quot;Unable to retrieve users&quot; }); }); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"api_controllers_DatabaseVersionController.js.html":{"id":"api_controllers_DatabaseVersionController.js.html","title":"Source: api/controllers/DatabaseVersionController.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: api/controllers/DatabaseVersionController.js &quot;use strict&quot;; var DatabaseVersion = require(&quot;../../models/DatabaseVersion&quot;); var Log = require(&quot;node-android-logging&quot;); module.exports = { getDatabaseVersion: getDatabaseVersion }; /** * getDatabaseVersion retrieves the Database Version from the database and returns it via the response. */ function getDatabaseVersion(request, response) { DatabaseVersion.select().then(function(databaseVersion) { response.json(databaseVersion); }).catch(function(rejection) { Log.E(rejection); response.status(500).json({ &quot;result&quot;: &quot;ERROR&quot;, &quot;message&quot;: &quot;Unable to retrieve database version&quot; }); }); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"api_controllers_LedgerEntriesController.js.html":{"id":"api_controllers_LedgerEntriesController.js.html","title":"Source: api/controllers/LedgerEntriesController.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: api/controllers/LedgerEntriesController.js &quot;use strict&quot;; var LedgerEntries = require(&quot;../../models/LedgerEntries&quot;); var Log = require(&quot;node-android-logging&quot;); var Q = require(&quot;q&quot;); module.exports = { getLedgerEntries: getLedgerEntries }; /** * getLedgerEntries retrieves the Ledger Entries from the database and returns them via the response. */ function getLedgerEntries(request, response) { LedgerEntries.select(request.query.offset, request.query.limit).then(function(ledgerEntries) { return LedgerEntries.count().then(function(count) { return new Q.Promise(function(resolve) { response.json({ &quot;length&quot;: ledgerEntries.length, &quot;results&quot;: ledgerEntries, &quot;count&quot;: count[0].count }); resolve(); }); }); }).catch(function(rejection) { Log.E(rejection); response.status(500).json({ &quot;result&quot;: &quot;ERROR&quot;, &quot;message&quot;: &quot;Unable to retrieve ledger entries&quot; }); }); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"api_controllers_UploadsController.js.html":{"id":"api_controllers_UploadsController.js.html","title":"Source: api/controllers/UploadsController.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: api/controllers/UploadsController.js &quot;use strict&quot;; var Uploads = require(&quot;../../models/Uploads&quot;); var Log = require(&quot;node-android-logging&quot;); var Q = require(&quot;q&quot;); module.exports = { getUploads: getUploads }; /** * getUploads retrieves the Uploads from the database and returns them via the response. */ function getUploads(request, response) { Uploads.select(request.query.offset, request.query.limit).then(function(uploads) { return Uploads.count().then(function(count) { return new Q.Promise(function(resolve) { response.json({ &quot;length&quot;: uploads.length, &quot;results&quot;: uploads, &quot;count&quot;: count[0].count }); resolve(); }); }); }).catch(function(rejection) { Log.E(rejection); response.status(500).json({ &quot;result&quot;: &quot;ERROR&quot;, &quot;message&quot;: &quot;Unable to retrieve uploads&quot; }); }); } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"app.js.html":{"id":"app.js.html","title":"Source: app.js","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Source: app.js &quot;use strict&quot;; var _ = require(&quot;underscore&quot;); var express = require(&quot;express&quot;); var conf = require(&quot;config&quot;); var fs = require(&quot;fs&quot;); var Log = require(&quot;node-android-logging&quot;); var mysqlc = require(&quot;./mysqlc&quot;); var dbUpgrade = require(&quot;./dbUpgrade&quot;); var swaggerInit = require(&quot;swagger-tools&quot;).initializeMiddleware; var app = express(); _.mixin({ coalesce: function() { for (let i = 0; i &lt; arguments.length; ++i) { let arg = arguments[i]; if ((!_.isNaN(arg)) &amp;&amp; (!_.isNull(arg)) &amp;&amp; (!_.isUndefined(arg))) { return arguments[i]; } } } }); module.exports = app; // for testing /* Access and error logs */ if (process.env.APACHE_LOGS !== undefined) { app.use(require(&quot;morgan&quot;)(&quot;combined&quot;)); } /* */ app.all(&quot;/*&quot;, function(req, res, next) { let root = __dirname + &quot;/node_modules/eledger-web&quot;; /* The default action is to send the index.html page and let Angular handle routing. * * The other actions include: * - Swagger API endpoint * - Static file endpoint */ var defaultAction = function() { res.sendFile(&quot;index.html&quot;, { root: root }); }; /* The Swagger API endpoints all start with /api */ if (req.path.startsWith(&quot;/api&quot;)) { /** I really don't want the browser to cache these api calls. **/ res.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); res.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); res.setHeader(&quot;Expires&quot;, 0); res.setHeader(&quot;Last-Modified&quot;, (new Date()).toUTCString()); /* Since we've established that this is not an angular endpoint, allow the next middleware to process. */ next(); } else { /* If the user is requesting one of the Angular routes, we'll send them the index.html file since Angular * handles it from there. * * In order to avoid hard coding the Angular routes into this program as well, we look to see if a static * file exists at the path they're requesting (within the root directory ./node_modules/eledger-web). * * If the file does exist at that path, they aren't requesting an API endpoint. * If no file exists at that path, they are requesting an Angular2 API endpoint. */ fs.lstat(root + req.path, function(err, stats) { if (err) { defaultAction(); } else { if (stats.isFile()) { res.sendFile(root + req.path); } else { defaultAction(); } } }); } }); /* Select a port */ var port; if (conf.has(&quot;port&quot;)) { port = conf.get(&quot;port&quot;); } /** * Order prefers: * - process.env.PORT * - config/**.json#port * - 4443 */ port = process.env.PORT || port || 4443; /* * Prepare DB */ try { mysqlc.connect(); dbUpgrade.initializeModels(); dbUpgrade.setupQueries(); dbUpgrade.upgrade(); } catch (ex) { Log.E(ex); process.exit(1); } var sourceFile = &quot;./api/swagger/index.json&quot;; swaggerInit(require(sourceFile), function (swaggerTools) { app.listen(port); app.use(swaggerTools.swaggerMetadata()); app.use(swaggerTools.swaggerValidator()); app.use(swaggerTools.swaggerRouter({ &quot;controllers&quot;: &quot;api/controllers&quot; })); app.use(swaggerTools.swaggerUi()); Log.I(&quot;Listening on port &quot; + port); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Global Members port Order prefers: process.env.PORT config/**.json#port 4443 Source: app.js, line 98 Methods addCreate(query) addCreate builds the list of create statements necessary to create the database from scratch This is unordered because I'm not using foreign keys, so the order of creation doesn't matter. Foreign key constraints must be handled by the software instead. Parameters: Name Type Description query String The query string for initially creating the model for a brand new database Source: dbUpgrade.js, line 18 addMigrate(sortFloatIndex, query) addMigrate builds the list of migration statements necessary to upgrade a database from any version to the latest Parameters: Name Type Description sortFloatIndex Number The sortFloatIndex in the ordered list to execute this migration statement. Filling in this value requires the developer to manually search through all of the models ({APP_ROOT}/models/*) in order to locate the highest sortFloatIndex used so far. The new call to this function should be one higher. This can be a decimal, so that you can insert between items if need be, but not more granular than 0.001 (I am multiplying by 1000 and storing in a BIGINT UNSIGNED field. query String The query string for initially creating the model for a brand new database Source: dbUpgrade.js, line 42 count() Selects the count from the given table and returns a Q.Promise to return the count. Source: models/DefaultModelActions.js, line 67 Returns: Q.Promise A promise to return the count Example // res.json sends a JSON string containing the uploads according to the parameters passed count().then(function(uploads) { res.json({ count: uploads[0].count }); }); get() get retrieves the UploadReadings from the database and returns them via the response. Source: api/controllers/UploadReadings.js, line 14 get() get retrieves the Users from the database and returns them via the response. Source: api/controllers/Users.js, line 14 getDatabaseVersion() getDatabaseVersion retrieves the Database Version from the database and returns it via the response. Source: api/controllers/DatabaseVersionController.js, line 13 getLedgerEntries() getLedgerEntries retrieves the Ledger Entries from the database and returns them via the response. Source: api/controllers/LedgerEntriesController.js, line 14 getUploads() getUploads retrieves the Uploads from the database and returns them via the response. Source: api/controllers/UploadsController.js, line 14 select( [offset] [, limit]) Selects from the database and returns a Q.Promise to return the results. Parameters: Name Type Argument Default Description offset number &lt;optional&gt; 0 The offset to request from within the result set limit number &lt;optional&gt; 0 The maximum number of records to request from within the result set Source: models/DefaultModelActions.js, line 40 Returns: Q.Promise A promise to return the results Example // res.json sends a JSON string containing the uploads according to the parameters passed select().then(function(uploads) { res.json(uploads); }); setupQueries() Sets up the create statements and migrate statements for each model. In order for this function to work, each model much specify an array of finalCreates (queries that can build the model from scratch in the database) and migrates (queries that can upgrade the model from any previous version). For an application example, see ./models/LedgerEntries.js Source: models/DefaultModelActions.js, line 107 Example // Provide queries to initially create the database. module.exports.initialCreates = [ ` CREATE TABLE Car ( id BIGINT UNSIGNED AUTO_INCREMENT, color VARCHAR(255) ); ` ]; // Map the initialCreates to a migrates query. Add each subsequent modification (ALTER TABLE) to future // sortFloatIndex values, while making sure not to step on the toes of other sortFloatIndices. module.exports.migrates = [ { sortFloatIndex: 0, query: module.exports.initialCreates[0] } ]; // Clone initialCreates initially. After alter tables, this array should always contain the latest // queries to build the database from scratch. module.exports.finalCreates = module.exports.initialCreates.slice(); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Global addCreateaddMigratecountgetgetDatabaseVersiongetLedgerEntriesgetUploadsportselectsetupQueries Eledger-API AboutEledger is an open source finance app. Eledger-api is the REST API which serves the finance data from a mysql database. This project is still a work in progress. × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-26T13:38:01-07:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
